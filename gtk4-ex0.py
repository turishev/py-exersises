import sys
import gi

gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Adw, Gio, Gdk, Graphene, GLib

# Реализация приложения в стиле объектно-ориентированного программирования (ООП), что вовсе необязатено, но допустим.
# Мы описываем КЛАССЫ объектов, это как бы инструкция по созданию ЭКЗЕМПЛЯРА объекта.
# Экземпляр - это то, что реально создаётся и потом работает. Класс - инструкция, описание.
# На базе одного класса можно создать много экземпляров объектов (или, иначе, просто объектов).

# Один класс может наследоваться от другого, таким образом его экземпляры могут использовать методы роджительского класса,
# и мы можем пользоваться кодом, который написан не нами.


# Создаём свой класс для главного окна приложения, который наследует классу Gtk.ApplicationWindow
# что означает, что он унаследует МЕТОДЫ Gtk.ApplicationWindow и они будут доступны для нашего приложения
# Реально мы определяем здесь  лишь несколько методов:  show_open_dialog, open_response, hello, bye и конструктор __init__
# Полное описание Gtk.ApplicationWindow здесь, но это для gtk-3 и по-английски
# https://python-gtk-3-tutorial.readthedocs.io/en/latest/application.html
#
# 
class MainWindow(Gtk.ApplicationWindow):
    # __init__ - конструктор класса - код который АВТОМАТИЧЕСКИ вызывается при создании, объекта,
    # имя с двумя подчеркиваниями, обычно означает некую специальную функцию
    # self - это собственно объект нашего класса, и мы его как-то настраиваем в конструкторе
    # Каждый метод класса будет получать первым параметром self АВТОМАТИЧЕСКИ, но мы должны его указывать в сигнатруе метода
    # Имя self - условное, можно называть иначе (первый параметр в сигнатуре), но так принято, и редакторы тоже это знают и подсвечивают
    # 
    # Собственно в конструкторе мы и строим всё окно.
    # 
    def __init__(self, *args, **kwargs):
        # нужно вызвать конструктор родительского класса, возможно там что-то тоже делается
        # super() - это получить родительский класс, после точки вызов его метода, т.е. __init__ - конструктора в данном случае
        # и передать ему те же аргументы:  *args, **kwargs
        super().__init__(*args, **kwargs)

        # поставить размеры окна и заголовок - унаследованные методы от Gtk.ApplicationWindow
        # формат любого вызова метода объекта: ЭКЗЕМПЛЯР_ОБЪЕКТА.НАЗВАНИЕ_МЕТОДА(АРГУМЕНТЫ)
        # здесь объект - это self
        self.set_default_size(600, 250) 
        self.set_title("Ex1")



# далее просто некое стандартное заклинание для запуска приложения        
class MyApp(Gtk.Application): # создаём класс приложения, наследуя его  от Gtk.Application
    def __init__(self, **kwargs): # конструктор класса
        super().__init__(**kwargs) # вызвать конструктор родительского класса
        self.connect('activate', self.on_activate) # подключить сигнал 'activate' к нашему обработчику on_activate

    def on_activate(self, app):
        self.win = MainWindow(application=app) # созадаём наше окно со всеми панельками и кнопками, сохраняем его в поле win приложения
        self.win.present() # показываем это окно


app = MyApp() # создать объект приложения, вызвав конструктор класса MyApp
app.run(sys.argv) # запустить приложение методом run, и передать ему аргументы (возможно ему интересно), что пользователь передал ему на консоли sys.argv
